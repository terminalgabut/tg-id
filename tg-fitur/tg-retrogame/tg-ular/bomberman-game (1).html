<!DOCTYPE html>
<html lang="id">  
<head>  
  <meta charset="UTF-8">  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">  
  <title>Snake Nokia | Terminal Gabut</title>  
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">  
  <script src="https://cdn.tailwindcss.com"></script>  
</head>  
<body class="bg-gray-100 flex flex-col min-h-screen">  

  <!-- NAVBAR -->  
  <header class="bg-blue-600 text-white fixed top-0 left-0 w-full shadow-md z-50">  
    <nav class="flex justify-between items-center bg-blue-600 text-white px-6 py-4 shadow-md">  
      <div>  
        <a href="../index.html">  
          <img src="IMG_20250825_090756-removebg-preview.png" alt="Terminal Gabut Logo" class="h-7 w-auto">  
        </a>  
      </div>  
      <ul class="hidden md:flex gap-6">  
        <li><a href="../index.html" class="hover:text-blue-200">Home</a></li>  
        <li><a href="#" class="hover:text-blue-200">Fitur</a></li>  
      </ul>  
      <button id="darkToggle" class="bg-white text-blue-600 px-3 py-1 rounded-md hover:bg-gray-200">üåô</button>  
    </nav>  
  </header>  

  <!-- CONTAINER -->  
  <div class="chat-container w-11/12 max-w-4xl mx-auto flex flex-col bg-white rounded-xl shadow-md mt-24 overflow-hidden">

    <!-- HEADER: Score/High Score/Length -->  
    <div class="header-container bg-blue-600 text-white flex justify-around p-4">  
      <div><strong>Score:</strong> <span id="scoreValue">0</span></div>  
      <div><strong>High:</strong> <span id="highValue">0</span></div>  
      <div><strong>Length:</strong> <span id="lengthValue">3</span></div>  
      <div><strong>Speed:</strong> <span id="speedValue">1</span></div>  
    </div>  

    <!-- GAME AREA - Made taller as per orange lines in image -->
    <div class="messages flex items-center justify-center bg-gray-50" style="height:600px">  
      <canvas id="gameCanvas" class="bg-black rounded border-2 border-blue-500"></canvas>  
    </div>  

    <!-- GAMEPAD -->  
    <div class="input-container flex flex-col items-center bg-white p-4 gap-3">  
      <div class="flex justify-center gap-6">  
        <button class="px-4 py-2 bg-blue-600 text-white rounded" onclick="movePlayer('left')">&#9664;</button>  
        <button class="px-4 py-2 bg-blue-600 text-white rounded" onclick="movePlayer('up')">&#9650;</button>  
        <button class="px-4 py-2 bg-blue-600 text-white rounded" onclick="movePlayer('down')">&#9660;</button>  
        <button class="px-4 py-2 bg-blue-600 text-white rounded" onclick="movePlayer('right')">&#9654;</button>  
      </div>  
      <div class="flex gap-6">  
        <button class="px-6 py-2 bg-green-500 text-white rounded" onclick="startGame()" id="startBtn">‚ñ∂ Start Game</button>  
        <button class="px-6 py-2 bg-yellow-500 text-white rounded" onclick="pauseGame()" id="pauseBtn">‚è∏ Pause</button>  
        <button class="px-6 py-2 bg-red-500 text-white rounded" onclick="toggleMute()" id="muteBtn">üîä Sound</button>  
      </div>  
    </div>  

  </div>  

  <footer class="text-center py-6 text-gray-500">¬© 2025 Terminal Gabut - Semua Hak Dilindungi</footer>

<script>
// Audio Manager
class AudioManager {
    constructor() {
        this.sounds = {};
        this.isMuted = false;
        this.isInitialized = false;
        this.loadSounds();
    }
    
    async loadSounds() {
        try {
            this.sounds.eat = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmEcBz2X3fPLcSMFL4DN8tiJOQcadLrr2Z5MEAxPqeHxtWUrBjiOz/LFXwgAWA==');
            this.sounds.death = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmEcBz2X3fPLcSMFL4DN8tiJOQcadLrr2Z5MEAxPqeHxtWUrBjiOz/LFXwgAWA==');
            
            Object.values(this.sounds).forEach(sound => {
                sound.volume = 0.3;
            });
        } catch (error) {
            console.warn('Audio loading failed:', error);
        }
    }
    
    async initAudio() {
        if (this.isInitialized) return;
        this.isInitialized = true;
    }
    
    playSound(soundName) {
        if (this.isMuted || !this.sounds[soundName] || !this.isInitialized) return;
        
        try {
            const sound = this.sounds[soundName].cloneNode();
            sound.volume = this.sounds[soundName].volume;
            sound.play().catch(e => console.warn(`Sound ${soundName} play failed:`, e));
        } catch (error) {
            console.warn(`Error playing sound ${soundName}:`, error);
        }
    }
    
    toggleMute() {
        this.isMuted = !this.isMuted;
        return this.isMuted;
    }
}

// Controls Manager
class ControlsManager {
    constructor() {
        this.keys = {};
        this.direction = null;
        this.nextDirection = null;
        this.setupKeyboardControls();
    }
    
    setupKeyboardControls() {
        document.addEventListener('keydown', (e) => {
            this.keys[e.code] = true;
            
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
                e.preventDefault();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            this.keys[e.code] = false;
        });
    }
    
    getDirection() {
        if (this.keys['ArrowUp'] || this.keys['KeyW']) return 'up';
        if (this.keys['ArrowDown'] || this.keys['KeyS']) return 'down';
        if (this.keys['ArrowLeft'] || this.keys['KeyA']) return 'left';
        if (this.keys['ArrowRight'] || this.keys['KeyD']) return 'right';
        
        if (this.direction) {
            const temp = this.direction;
            this.direction = null;
            return temp;
        }
        
        return null;
    }
    
    setDirection(dir) {
        this.direction = dir;
    }
}

// Food class
class Food {
    constructor(width, height, cellSize) {
        this.width = width;
        this.height = height;
        this.cellSize = cellSize;
        this.x = 0;
        this.y = 0;
        this.generateNewFood();
    }
    
    generateNewFood() {
        this.x = Math.floor(Math.random() * (this.width - 2)) + 1;
        this.y = Math.floor(Math.random() * (this.height - 2)) + 1;
    }
    
    render(ctx) {
        ctx.fillStyle = '#FF0000';
        ctx.fillRect(
            this.x * this.cellSize + 2,
            this.y * this.cellSize + 2,
            this.cellSize - 4,
            this.cellSize - 4
        );
    }
    
    getPosition() {
        return { x: this.x, y: this.y };
    }
}

// Snake class
class Snake {
    constructor(startX, startY) {
        this.body = [
            { x: startX, y: startY },
            { x: startX - 1, y: startY },
            { x: startX - 2, y: startY }
        ];
        this.direction = 'right';
        this.nextDirection = 'right';
        this.growing = false;
    }
    
    update() {
        // Update direction if valid (prevent 180-degree turn)
        if (this.isValidDirection(this.nextDirection)) {
            this.direction = this.nextDirection;
        }
        
        // Calculate new head position
        const head = { ...this.body[0] };
        
        switch (this.direction) {
            case 'up':
                head.y -= 1;
                break;
            case 'down':
                head.y += 1;
                break;
            case 'left':
                head.x -= 1;
                break;
            case 'right':
                head.x += 1;
                break;
        }
        
        // Add new head
        this.body.unshift(head);
        
        // Remove tail unless growing
        if (!this.growing) {
            this.body.pop();
        } else {
            this.growing = false;
        }
    }
    
    isValidDirection(newDirection) {
        const opposites = {
            'up': 'down',
            'down': 'up',
            'left': 'right',
            'right': 'left'
        };
        
        return opposites[this.direction] !== newDirection;
    }
    
    setDirection(direction) {
        this.nextDirection = direction;
    }
    
    grow() {
        this.growing = true;
    }
    
    checkCollision(width, height) {
        const head = this.body[0];
        
        // Wall collision
        if (head.x < 0 || head.x >= width || head.y < 0 || head.y >= height) {
            return true;
        }
        
        // Self collision
        for (let i = 1; i < this.body.length; i++) {
            if (head.x === this.body[i].x && head.y === this.body[i].y) {
                return true;
            }
        }
        
        return false;
    }
    
    eatFood(food) {
        const head = this.body[0];
        const foodPos = food.getPosition();
        
        if (head.x === foodPos.x && head.y === foodPos.y) {
            this.grow();
            return true;
        }
        
        return false;
    }
    
    render(ctx, cellSize) {
        // Draw snake head
        ctx.fillStyle = '#00FF00';
        const head = this.body[0];
        ctx.fillRect(
            head.x * cellSize + 1,
            head.y * cellSize + 1,
            cellSize - 2,
            cellSize - 2
        );
        
        // Draw snake body
        ctx.fillStyle = '#90EE90';
        for (let i = 1; i < this.body.length; i++) {
            const segment = this.body[i];
            ctx.fillRect(
                segment.x * cellSize + 1,
                segment.y * cellSize + 1,
                cellSize - 2,
                cellSize - 2
            );
        }
    }
    
    getLength() {
        return this.body.length;
    }
    
    reset(startX, startY) {
        this.body = [
            { x: startX, y: startY },
            { x: startX - 1, y: startY },
            { x: startX - 2, y: startY }
        ];
        this.direction = 'right';
        this.nextDirection = 'right';
        this.growing = false;
    }
}

// Main Snake Game class
class SnakeGame {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        this.state = 'start';
        this.score = 0;
        this.highScore = localStorage.getItem('snakeHighScore') || 0;
        this.level = 1;
        
        this.gridWidth = 25;
        this.gridHeight = 20;
        this.cellSize = 20;
        
        this.snake = null;
        this.food = null;
        
        this.gameSpeed = 200; // milliseconds
        this.lastMoveTime = 0;
        this.lastTime = 0;
        this.gameLoop = this.gameLoop.bind(this);
        
        this.setupCanvas();
        this.initializeGame();
    }
    
    setupCanvas() {
        this.canvas.width = this.gridWidth * this.cellSize;
        this.canvas.height = this.gridHeight * this.cellSize;
        
        this.resizeCanvas();
        window.addEventListener('resize', () => this.resizeCanvas());
    }
    
    resizeCanvas() {
        const container = this.canvas.parentElement;
        const containerWidth = container.clientWidth;
        const containerHeight = 600;
        
        const scaleX = containerWidth / this.canvas.width;
        const scaleY = containerHeight / this.canvas.height;
        const scale = Math.min(scaleX, scaleY, 1);
        
        this.canvas.style.width = (this.canvas.width * scale) + 'px';
        this.canvas.style.height = (this.canvas.height * scale) + 'px';
    }
    
    initializeGame() {
        const startX = Math.floor(this.gridWidth / 2);
        const startY = Math.floor(this.gridHeight / 2);
        
        this.snake = new Snake(startX, startY);
        this.food = new Food(this.gridWidth, this.gridHeight, this.cellSize);
        
        // Make sure food doesn't spawn on snake
        this.generateValidFood();
    }
    
    generateValidFood() {
        let validPosition = false;
        
        while (!validPosition) {
            this.food.generateNewFood();
            const foodPos = this.food.getPosition();
            
            validPosition = true;
            for (let segment of this.snake.body) {
                if (segment.x === foodPos.x && segment.y === foodPos.y) {
                    validPosition = false;
                    break;
                }
            }
        }
    }
    
    async startGame() {
        await audioManager.initAudio();
        
        this.state = 'playing';
        this.lastTime = performance.now();
        this.lastMoveTime = performance.now();
        requestAnimationFrame(this.gameLoop);
    }
    
    pauseGame() {
        if (this.state === 'playing') {
            this.state = 'paused';
            document.getElementById('pauseBtn').textContent = '‚ñ∂ Resume';
        } else if (this.state === 'paused') {
            this.state = 'playing';
            this.lastTime = performance.now();
            this.lastMoveTime = performance.now();
            requestAnimationFrame(this.gameLoop);
            document.getElementById('pauseBtn').textContent = '‚è∏ Pause';
        }
    }
    
    gameLoop(currentTime) {
        if (this.state !== 'playing') return;
        
        const deltaTime = currentTime - this.lastTime;
        this.lastTime = currentTime;
        
        this.update(currentTime);
        this.render();
        
        requestAnimationFrame(this.gameLoop);
    }
    
    update(currentTime) {
        // Handle input
        const direction = controlsManager.getDirection();
        if (direction) {
            this.snake.setDirection(direction);
        }
        
        // Move snake based on game speed
        if (currentTime - this.lastMoveTime >= this.gameSpeed) {
            this.snake.update();
            this.lastMoveTime = currentTime;
            
            // Check food collision
            if (this.snake.eatFood(this.food)) {
                audioManager.playSound('eat');
                this.score += 10;
                this.updateScoreDisplay();
                this.generateValidFood();
                
                // Increase speed slightly
                if (this.gameSpeed > 80) {
                    this.gameSpeed -= 2;
                    this.level = Math.floor((this.snake.getLength() - 3) / 5) + 1;
                    this.updateSpeedDisplay();
                }
            }
            
            // Check collisions
            if (this.snake.checkCollision(this.gridWidth, this.gridHeight)) {
                this.gameOver();
            }
        }
    }
    
    gameOver() {
        this.state = 'gameOver';
        audioManager.playSound('death');
        
        // Update high score
        if (this.score > this.highScore) {
            this.highScore = this.score;
            localStorage.setItem('snakeHighScore', this.highScore);
            this.updateHighScoreDisplay();
        }
        
        setTimeout(() => {
            alert(`Game Over! Score: ${this.score}\\nHigh Score: ${this.highScore}\\nLength: ${this.snake.getLength()}`);
        }, 100);
    }
    
    resetGame() {
        this.state = 'start';
        this.score = 0;
        this.level = 1;
        this.gameSpeed = 200;
        
        this.initializeGame();
        
        this.updateScoreDisplay();
        this.updateLengthDisplay();
        this.updateSpeedDisplay();
        
        document.getElementById('startBtn').textContent = '‚ñ∂ Start Game';
        document.getElementById('pauseBtn').textContent = '‚è∏ Pause';
    }
    
    updateScoreDisplay() {
        document.getElementById('scoreValue').textContent = this.score;
        this.updateLengthDisplay();
    }
    
    updateHighScoreDisplay() {
        document.getElementById('highValue').textContent = this.highScore;
    }
    
    updateLengthDisplay() {
        document.getElementById('lengthValue').textContent = this.snake ? this.snake.getLength() : 3;
    }
    
    updateSpeedDisplay() {
        document.getElementById('speedValue').textContent = this.level;
    }
    
    render() {
        // Clear canvas with Nokia-style black background
        this.ctx.fillStyle = '#000000';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Draw border (Nokia style)
        this.ctx.strokeStyle = '#00FF00';
        this.ctx.lineWidth = 2;
        this.ctx.strokeRect(1, 1, this.canvas.width - 2, this.canvas.height - 2);
        
        // Draw grid (subtle)
        this.ctx.strokeStyle = '#001100';
        this.ctx.lineWidth = 1;
        for (let x = 0; x <= this.gridWidth; x++) {
            this.ctx.beginPath();
            this.ctx.moveTo(x * this.cellSize, 0);
            this.ctx.lineTo(x * this.cellSize, this.canvas.height);
            this.ctx.stroke();
        }
        for (let y = 0; y <= this.gridHeight; y++) {
            this.ctx.beginPath();
            this.ctx.moveTo(0, y * this.cellSize);
            this.ctx.lineTo(this.canvas.width, y * this.cellSize);
            this.ctx.stroke();
        }
        
        // Render food
        if (this.food) {
            this.food.render(this.ctx);
        }
        
        // Render snake
        if (this.snake) {
            this.snake.render(this.ctx, this.cellSize);
        }
        
        // Game over overlay
        if (this.state === 'gameOver') {
            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            
            this.ctx.fillStyle = '#00FF00';
            this.ctx.font = 'bold 24px monospace';
            this.ctx.textAlign = 'center';
            this.ctx.fillText('GAME OVER', this.canvas.width / 2, this.canvas.height / 2 - 20);
            
            this.ctx.font = '16px monospace';
            this.ctx.fillText(`Score: ${this.score}`, this.canvas.width / 2, this.canvas.height / 2 + 10);
            this.ctx.fillText(`Length: ${this.snake.getLength()}`, this.canvas.width / 2, this.canvas.height / 2 + 30);
        }
        
        // Paused overlay
        if (this.state === 'paused') {
            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            
            this.ctx.fillStyle = '#00FF00';
            this.ctx.font = 'bold 24px monospace';
            this.ctx.textAlign = 'center';
            this.ctx.fillText('PAUSED', this.canvas.width / 2, this.canvas.height / 2);
        }
    }
}

// Global instances
const audioManager = new AudioManager();
const controlsManager = new ControlsManager();
let game = null;

// Control functions
function movePlayer(direction) {
    if (game && game.state === 'playing') {
        controlsManager.setDirection(direction);
    }
}

function startGame() {
    if (!game) {
        game = new SnakeGame();
        game.updateHighScoreDisplay();
    }
    
    if (game.state === 'start' || game.state === 'gameOver') {
        game.resetGame();
        game.startGame();
        document.getElementById('startBtn').textContent = 'üîÑ Restart';
        document.getElementById('pauseBtn').textContent = '‚è∏ Pause';
    } else if (game.state === 'playing') {
        game.pauseGame();
        document.getElementById('startBtn').textContent = 'üîÑ Restart';
    } else if (game.state === 'paused') {
        game.startGame();
        document.getElementById('startBtn').textContent = 'üîÑ Restart';
        document.getElementById('pauseBtn').textContent = '‚è∏ Pause';
    }
}

function pauseGame() {
    if (game && (game.state === 'playing' || game.state === 'paused')) {
        game.pauseGame();
    }
}

function toggleMute() {
    const isMuted = audioManager.toggleMute();
    document.getElementById('muteBtn').textContent = isMuted ? 'üîá Sound' : 'üîä Sound';
}

// Keyboard controls
document.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowLeft') movePlayer('left');
    else if (e.key === 'ArrowRight') movePlayer('right');
    else if (e.key === 'ArrowUp') movePlayer('up');
    else if (e.key === 'ArrowDown') movePlayer('down');
    else if (e.key === ' ') {
        e.preventDefault();
        pauseGame();
    } else if (e.key.toLowerCase() === 'p') {
        e.preventDefault();
        pauseGame();
    } else if (e.key.toLowerCase() === 's') {
        e.preventDefault();
        startGame();
    }
});

// Initialize game when page loads
window.addEventListener('load', () => {
    game = new SnakeGame();
    game.updateHighScoreDisplay();
});
</script>
</body>
</html>