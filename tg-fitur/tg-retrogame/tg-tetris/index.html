<!doctype html>

<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tetris - Simple HTML/JS</title>
  <style>
    :root{
      --bg:#0b0f1a; --panel:#0f1724; --accent:#22c1c3; --muted:#94a3b8;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:Inter, system-ui, Arial;background:linear-gradient(180deg,#071029 0%, #071123 100%);color:#e6eef6;display:flex;align-items:center;justify-content:center;height:100vh}
    .container{display:flex;gap:24px;align-items:flex-start}
    .game{background:var(--panel);padding:16px;border-radius:12px;box-shadow:0 8px 30px rgba(2,6,23,.6)}
    canvas{background:#071127;display:block;border-radius:8px}
    .sidebar{width:220px;padding:12px;background:rgba(255,255,255,.02);border-radius:12px}
    h1{font-size:18px;margin:0 0 8px}
    .info{margin-bottom:8px;color:var(--muted)}
    .stat{display:flex;justify-content:space-between;padding:6px 8px;border-radius:8px;margin-bottom:8px;background:rgba(255,255,255,.02)}
    .controls{font-size:13px;color:var(--muted)}
    .btn{display:inline-block;padding:8px 12px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,.06);cursor:pointer;color:var(--accent);margin-top:8px}
    footer{font-size:12px;color:var(--muted);margin-top:12px}
  </style>
</head>
<body>
  <div class="container">
    <div class="game">
      <canvas id="board" width="240" height="480"></canvas>
    </div>
    <div class="sidebar">
      <h1>Tetris — Simple</h1>
      <div class="info">Kontrol: ← → ↓ putar: ↑ atau X, space: hard drop, P: pause</div>
      <div class="stat"><strong>Score</strong><span id="score">0</span></div>
      <div class="stat"><strong>Lines</strong><span id="lines">0</span></div>
      <div class="stat"><strong>Level</strong><span id="level">1</span></div>
      <div class="stat"><strong>Next</strong><canvas id="next" width="100" height="100"></canvas></div>
      <button id="restart" class="btn">Mulai Ulang</button>
      <button id="pause" class="btn">Pause (P)</button>
      <footer>Siap untuk dipublikasikan di GitHub Pages — cukup simpan sebagai <code>tetris.html</code></footer>
    </div>
  </div><script>
// Simple Tetris implementation
const COLS = 10, ROWS = 20, BLOCK = 24;
const board = document.getElementById('board');
const ctx = board.getContext('2d');
board.width = COLS * BLOCK; board.height = ROWS * BLOCK;
const nextCanvas = document.getElementById('next');
const nctx = nextCanvas.getContext('2d');
let scoreEl = document.getElementById('score'), linesEl=document.getElementById('lines'), levelEl=document.getElementById('level');

function makeEmptyBoard(){
  return Array.from({length:ROWS},()=>Array(COLS).fill(0));
}
let grid = makeEmptyBoard();

const SHAPES = {
  I: [[1,1,1,1]],
  J: [[2,0,0],[2,2,2]],
  L: [[0,0,3],[3,3,3]],
  O: [[4,4],[4,4]],
  S: [[0,5,5],[5,5,0]],
  T: [[0,6,0],[6,6,6]],
  Z: [[7,7,0],[0,7,7]]
};
const COLORS = ['','#00e5ff','#0066ff','#ff8c42','#ffd11a','#00d166','#b84dff','#ff3b3b'];
const BAG = [];
function nextPieceType(){
  if(BAG.length===0){
    const types = Object.keys(SHAPES).slice();
    for(let i=types.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[types[i],types[j]]=[types[j],types[i]]}
    BAG.push(...types);
  }
  return BAG.shift();
}

function cloneShape(matrix){ return matrix.map(r=>r.slice()); }
function rotate(matrix){
  const m = matrix.map((r,i)=>r.map((_,j)=>matrix[matrix.length-1-j][i]));
  // remove empty rows/cols for neatness
  return m;
}

class Piece{
  constructor(type){
    this.type = type;
    this.matrix = cloneShape(SHAPES[type]);
    this.row = 0; this.col = Math.floor(COLS/2 - this.matrix[0].length/2);
    this.color = COLORS[Object.keys(SHAPES).indexOf(type)+1];
  }
}

let current = new Piece(nextPieceType());
let next = new Piece(nextPieceType());

function collide(grid, piece, rOffset=0, cOffset=0){
  const m = piece.matrix;
  for(let r=0;r<m.length;r++){
    for(let c=0;c<m[r].length;c++){
      if(m[r][c]){
        const nr = piece.row + r + rOffset;
        const nc = piece.col + c + cOffset;
        if(nr<0 || nc<0 || nc>=COLS || nr>=ROWS) return true;
        if(grid[nr][nc]) return true;
      }
    }
  }
  return false;
}

function merge(grid,piece){
  const m = piece.matrix;
  for(let r=0;r<m.length;r++)for(let c=0;c<m[r].length;c++)if(m[r][c]) grid[piece.row+r][piece.col+c]=m[r][c];
}

function clearLines(){
  let lines = 0;
  for(let r=ROWS-1;r>=0;r--){
    if(grid[r].every(v=>v!==0)){
      grid.splice(r,1); grid.unshift(Array(COLS).fill(0)); lines++; r++; // recheck the same row after shift
    }
  }
  return lines;
}

let score=0, lines=0, level=1, dropInterval=800;
function updateScore(cleared){
  if(cleared>0){
    const points = [0,40,100,300,1200];
    score += points[cleared]*level;
    lines += cleared;
    level = Math.floor(lines/10)+1;
    dropInterval = Math.max(100,800 - (level-1)*60);
    scoreEl.textContent = score; linesEl.textContent = lines; levelEl.textContent = level;
  }
}

function spawn(){
  current = next; next = new Piece(nextPieceType());
  current.row = 0; current.col = Math.floor(COLS/2 - current.matrix[0].length/2);
  if(collide(grid,current)){ gameOver(); }
}

function gameOver(){
  running=false; alert('Game Over! Score: '+score);
}

function hardDrop(){
  while(!collide(grid,current,1,0)) current.row++;
  lockPiece();
}

function lockPiece(){
  merge(grid,current);
  const cleared = clearLines();
  updateScore(cleared);
  spawn();
}

function step(){
  if(!running) return;
  const now = Date.now();
  if(now - lastDrop > dropInterval){
    if(!collide(grid,current,1,0)) current.row++; else lockPiece();
    lastDrop = now;
  }
  draw();
  requestAnimationFrame(step);
}

function drawCell(x,y,val){
  ctx.fillStyle = val? COLORS[val] : '#0b1220';
  ctx.fillRect(x*BLOCK+1,y*BLOCK+1,BLOCK-2,BLOCK-2);
}
function draw(){
  // background
  ctx.fillStyle='#071127'; ctx.fillRect(0,0,board.width,board.height);
  // board
  for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++) drawCell(c,r,grid[r][c]);
  // current piece
  const m = current.matrix;
  for(let r=0;r<m.length;r++)for(let c=0;c<m[r].length;c++) if(m[r][c]) drawCell(current.col+c, current.row+r, m[r][c]);
  // grid lines (optional subtle)
}

function drawNext(){
  nctx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
  nctx.fillStyle='#071127'; nctx.fillRect(0,0,nextCanvas.width,nextCanvas.height);
  const m = next.matrix; const size = BLOCK-6; const offsetX=10, offsetY=10;
  for(let r=0;r<m.length;r++)for(let c=0;c<m[r].length;c++){
    if(m[r][c]){
      nctx.fillStyle = COLORS[m[r][c]]; nctx.fillRect(offsetX + c*size, offsetY + r*size, size-2, size-2);
    }
  }
}

// Controls
document.addEventListener('keydown',e=>{
  if(!running && e.key.toLowerCase()!=='p') return;
  if(e.key==='ArrowLeft'){ if(!collide(grid,current,0,-1)) current.col--; }
  else if(e.key==='ArrowRight'){ if(!collide(grid,current,0,1)) current.col++; }
  else if(e.key==='ArrowDown'){ if(!collide(grid,current,1,0)) current.row++; lastDrop=Date.now(); }
  else if(e.key==='ArrowUp' || e.key.toLowerCase()==='x'){ // rotate
    const rotated = rotate(current.matrix);
    const old = current.matrix; current.matrix = rotated;
    if(collide(grid,current,0,0)) current.matrix = old; // simple wallkick fail
  }
  else if(e.key===' '){ e.preventDefault(); hardDrop(); }
  else if(e.key.toLowerCase()==='p'){ togglePause(); }
  draw();
});

let running = true; let lastDrop = Date.now();

function togglePause(){ running = !running; document.getElementById('pause').textContent = running? 'Pause (P)':'Resume (P)'; if(running){ lastDrop = Date.now(); step(); } }

// Buttons
document.getElementById('restart').addEventListener('click',()=>{
  grid = makeEmptyBoard(); score=0; lines=0; level=1; dropInterval=800; scoreEl.textContent='0'; linesEl.textContent='0'; levelEl.textContent='1'; BAG.length=0; current = new Piece(nextPieceType()); next = new Piece(nextPieceType()); running=true; lastDrop=Date.now(); step(); drawNext();});

document.getElementById('pause').addEventListener('click',togglePause);

// start
spawn(); drawNext(); draw(); let tick = setInterval(()=>{ drawNext(); },200); step();

</script></body>
</html>
